export const TILE = {
  EMPTY: 0,
  DIRT: 1,
  WALL: 2,
  STEEL: 3,
  BOULDER: 4,
  GEM: 5,
  EXIT_CLOSED: 6,
  EXIT_OPEN: 7,
};

export const DIRS = {
  UP: {x:0,y:-1}, DOWN: {x:0,y:1}, LEFT: {x:-1,y:0}, RIGHT: {x:1,y:0}
};

export function createWorld(levelDef) {
  const rows = levelDef.map.trim().split('\n');
  const height = rows.length; const width = rows[0].length;
  const tilesize = 8;
  const t = new Uint8Array(width*height);
  // falling marks tiles that were falling in the previous tick
  let falling = new Uint8Array(width*height);
  let player = {x:1,y:1};
  let gemsTotal = 0;
  for (let y=0;y<height;y++){
    for(let x=0;x<width;x++){
      const ch = rows[y][x];
      let id = TILE.EMPTY;
      if (ch === '#') id = TILE.WALL;
      else if (ch === 'X') id = TILE.STEEL;
      else if (ch === '.') id = TILE.DIRT;
      else if (ch === 'o') id = TILE.BOULDER;
      else if (ch === '*') { id = TILE.GEM; gemsTotal++; }
      else if (ch === 'E') id = TILE.EXIT_CLOSED;
      else if (ch === ' ') id = TILE.EMPTY;
      else if (ch === 'P') { id = TILE.EMPTY; player = {x,y}; }
      t[y*width+x] = id;
    }
  }
  // Compute reachable gems from player position (flood fill over passable tiles)
  function reachableGemCount() {
    const visited = new Uint8Array(width*height);
    const qx = new Int16Array(width*height);
    const qy = new Int16Array(width*height);
    let head = 0, tail = 0;
    qx[tail] = player.x; qy[tail] = player.y; tail++;
    let gems = 0;
    const passable = (id)=> id===TILE.EMPTY || id===TILE.DIRT || id===TILE.GEM || id===TILE.EXIT_OPEN;
    while (head < tail) {
      const x = qx[head], y = qy[head]; head++;
      const i = y*width + x; if (visited[i]) continue; visited[i]=1;
      const id = t[i]; if (id===TILE.GEM) gems++;
      // 4-neighborhood
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (let k=0;k<4;k++){ const nx = x+dirs[k][0], ny = y+dirs[k][1];
        if (nx<0||ny<0||nx>=width||ny>=height) continue;
        const nid = t[ny*width+nx]; if (!passable(nid)) continue;
        const ni = ny*width+nx; if (visited[ni]) continue;
        qx[tail]=nx; qy[tail]=ny; tail++;
      }
    }
    return gems;
  }

  const reachableGems = reachableGemCount();
  const computedRequirement = (reachableGems>0) ? Math.max(1, Math.floor(reachableGems*0.8)) : 0;
  const world = {
    width, height, tilesize, t,
    falling,
    player,
    collected: 0, gemsRequired: computedRequirement,
    score: 0,
    timeLeft: 120,
    state: 'play', // play | dead | timeup | win
    tick: 0,
    idx(x,y){ return y*width+x; },
    inb(x,y){ return x>=0 && y>=0 && x<width && y<height; },
    get(x,y){ return this.inb(x,y) ? t[this.idx(x,y)] : TILE.STEEL; },
    set(x,y,v){ if(this.inb(x,y)) t[this.idx(x,y)] = v; },
    isFree(x,y){ const id=this.get(x,y); return id===TILE.EMPTY || id===TILE.DIRT || id===TILE.GEM || id===TILE.EXIT_OPEN; },
    tryMovePlayer(dir){
      if (this.state!=='play') return false;
      const nx = this.player.x + dir.x; const ny = this.player.y + dir.y;
      const id = this.get(nx,ny);
      // pushing boulders (cannot push a currently falling rock)
      if ((id===TILE.BOULDER) && (dir.x!==0 && dir.y===0)){
        const bx = nx + dir.x; const by = ny + dir.y;
        if (this.get(bx,by)===TILE.EMPTY && this.falling[this.idx(nx,ny)]===0) {
          this.set(bx,by,TILE.BOULDER); this.set(nx,ny,TILE.EMPTY);
          this.player.x = nx; this.player.y = ny;
          this._on('push');
          return true;
        }
      }
      if (id===TILE.WALL || id===TILE.STEEL || id===TILE.BOULDER || id===TILE.EXIT_CLOSED) return false;
      // collect gem
      if (id===TILE.GEM) { this.collected++; this.score += 15; this._on('collect'); }
      // dig dirt
      if (id===TILE.DIRT) { this.score += 1; }
      // move
      this.set(nx,ny, TILE.EMPTY);
      this.player.x = nx; this.player.y = ny;
      // open exit if ready
      if (this.collected >= this.gemsRequired) this.openExits();
      // win condition
      if (id===TILE.EXIT_OPEN) { this.state='win'; this._on('win'); }
      return true;
    },
    openExits(){
      for (let y=0;y<height;y++) for (let x=0;x<width;x++) if (this.get(x,y)===TILE.EXIT_CLOSED) this.set(x,y,TILE.EXIT_OPEN);
      this._on('exit-open');
    },
    update(dt){
      if (this.state!=='play') return;
      this.tick++;
      this.timeLeft -= dt;
      if (this.timeLeft <= 0) { this.state='timeup'; return {type:'die'}; }

      const wasFalling = this.falling;                 // from previous tick
      const nextFalling = new Uint8Array(width*height); // for this tick results

      // process gravity bottom->top
// Enemies + explosions (auto-wired)ntry { enemiesStep(world); resolveExplosions(world); } catch(e) { console.warn('wire-loop-hooks:', e); }n      for (let y=this.height-2; y>=0; y--) {
        for (let x=0; x<this.width; x++) {
          const id = this.get(x,y);
          if (id!==TILE.BOULDER && id!==TILE.GEM) continue;

          const i = this.idx(x,y);
          const fallingBefore = wasFalling[i] === 1;

          const belowTile = this.get(x,y+1);
          const playerBelow = (this.player.x===x && this.player.y===y+1);

          // Vertical fall logic: player counts as support UNLESS the rock was already falling
          if (belowTile === TILE.EMPTY) {
            if (playerBelow) {
              if (fallingBefore) {
                // crush and continue falling into player's cell
                this.state='dead'; this._on('die');
                this.set(x,y, TILE.EMPTY);
                this.set(x,y+1, id);
                nextFalling[this.idx(x,y+1)] = 1;
              } else {
                // player is supporting the rock this tick; do not move
                // not marked as falling yet
              }
              continue;
            } else {
              // free fall into empty space
              this.set(x,y+1,id); this.set(x,y,TILE.EMPTY);
              nextFalling[this.idx(x,y+1)] = 1;
              continue;
            }
          }

          const isRocky = (v)=> v===TILE.BOULDER || v===TILE.GEM;
          // Rolling behavior (treat player's cells as blocking unless already falling)
          if (isRocky(belowTile)) {
            // roll left
            const leftFree = this.get(x-1,y)===TILE.EMPTY && !(this.player.x===x-1 && this.player.y===y);
            const downLeftFree = this.get(x-1,y+1)===TILE.EMPTY && !(this.player.x===x-1 && this.player.y===y+1);
            if (leftFree && downLeftFree) {
              if (this.player.x===x-1 && this.player.y===y+1) {
                if (fallingBefore) { this.state='dead'; this._on('die'); }
                else { continue; }
              }
              this.set(x-1,y+1,id); this.set(x,y,TILE.EMPTY);
              nextFalling[this.idx(x-1,y+1)] = 1; continue;
            }
            // roll right
            const rightFree = this.get(x+1,y)===TILE.EMPTY && !(this.player.x===x+1 && this.player.y===y);
            const downRightFree = this.get(x+1,y+1)===TILE.EMPTY && !(this.player.x===x+1 && this.player.y===y+1);
            if (rightFree && downRightFree) {
              if (this.player.x===x+1 && this.player.y===y+1) {
                if (fallingBefore) { this.state='dead'; this._on('die'); }
                else { continue; }
              }
              this.set(x+1,y+1,id); this.set(x,y,TILE.EMPTY);
              nextFalling[this.idx(x+1,y+1)] = 1; continue;
            }
          }
          // otherwise: resting
        }
      }

      this.falling = nextFalling;
      return null;
    },
    _on(type, payload){ this._lastEvent = {type,payload}; setTimeout(()=>{ this._lastEvent=null; },0); },
  };
  if (world.gemsRequired === 0) world.openExits();
  if (world.gemsRequired === 0) world.openExits();
  world.queueExplosion=(...a)=>queueExplosion(world,...a); return world;
}
// --- Enemies + Explosions scaffold (Phase 1) ---
export const ENEMY_TYPES = { FIREFLY: 'FIREFLY', BUTTERFLY: 'BUTTERFLY' };
export const DIR = { R:0, D:1, L:2, U:3 };
// Explosion queue items: {x,y,ttl,kind:'FIRE'|'BUTTER'}
// Enemies: {x,y,dir,type}
// Integration points to wire into tick order:
// 1) gravityStep(); 2) enemiesStep(world); 3) resolveExplosions(world); 4) applyPlayer(world); 5) sfx hooks
// Hook registration (implemented in sys/explosions.js)
import { enemiesStep } from './entities/enemies.js';
import { queueExplosion, resolveExplosions } from './sys/explosions.js';

// World should expose helpers used by systems above:
// - isPassable(x,y), isSteel(x,y), isExit(x,y), setGem(x,y), clearTile(x,y)
// - player {x,y}
// - enemies: []
// Wire into main tick: gravity -> enemiesStep(this) -> resolveExplosions(this) -> player
// Provide world.queueExplosion = (...args)=>queueExplosion(this,...args)
if(typeof globalThis!=='undefined'){
  // attach at module eval for simplicity in this scaffold; real code should set on construction
}
// --- Magic Wall scaffold (Phase 3) ---
export const MAGIC_WALL = { INACTIVE:0, ACTIVE:1, SPENT:2 };
// world.magicActiveUntil, world.magicDuration
// world.isMagicWall(x,y) -> state; world.setMagicWall(x,y,state)
// During gravity step, if a falling boulder/diamond enters an ACTIVE wall cell, convert and place below.
// Auto-wired Magic Wall conversion helper (call from gravity when an item enters ACTIVE)
export function magicConvert(world, x, y, item){
  // item: 'BOULDER'|'GEM'; assumes (x,y) is wall cell; output placed at (x,y+1) if empty
  if(!world.isMagicWall||!world.setMagicWall) return;
  const state = world.isMagicWall(x,y);
  if(state!==1 /* ACTIVE */) return;
  const belowX=x, belowY=y+1;
  if(!world.isPassable(belowX,belowY)) return;
  if(item==='BOULDER'){ world.setGem(belowX,belowY); }
  else if(item==='GEM'){ world.setBoulder(belowX,belowY); }
}
